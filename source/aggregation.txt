.. _csharp-aggregation:

======================
Aggregation Operations
======================

.. facet::
   :name: genre
   :values: reference

.. meta::
   :keywords: dotnet, code example, transform, pipeline

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. toctree::
   :titlesonly:
   :maxdepth: 1

   Aggregation Stages </aggregation/stages>

Overview
--------

In this guide, you can learn how to use the {+driver-long+} to perform
**aggregation operations**.

Aggregation operations process data in your MongoDB collections and
return computed results. The MongoDB Aggregation framework is modeled on the 
concept of data processing pipelines. Documents enter a pipeline comprised of one or
more stages, and this pipeline transforms the documents into an aggregated result.

To learn more about the Aggregation Pipeline, see the
:manual:`Aggregation Pipeline </core/aggregation-pipeline/>` server manual page.

Analogy
~~~~~~~

Aggregation operations function similarly to car factories with assembly
lines. The assembly lines have stations with specialized tools to
perform specific tasks. For example, when building a car, the assembly
line begins with the frame. Then, as the car frame moves through the
assembly line, each station assembles a separate part. The result is a
transformed final product, the finished car.

The assembly line represents the *aggregation pipeline*, the individual
stations represent the *aggregation stages*, the specialized tools
represent the *expression operators*, and the finished product
represents the *aggregated result*.

Compare Aggregation and Find Operations
---------------------------------------

The following table lists the different tasks you can perform with find
operations, compared to what you can achieve with aggregation
operations. The aggregation framework provides expanded functionality
that allows you to transform and manipulate your data.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Find Operations
     - Aggregation Operations

   * - | Select *certain* documents to return
       | Select *which* fields to return
       | Sort the results
       | Limit the results
       | Count the results
     - | Select *certain* documents to return
       | Select *which* fields to return
       | Sort the results
       | Limit the results
       | Count the results
       | Group the results
       | Rename fields
       | Compute new fields
       | Summarize data
       | Connect and merge data sets

Server Limitations
------------------

Consider the following :manual:`limitations </core/aggregation-pipeline-limits/>` when 
performing aggregation operations:

- Returned documents must not violate the :manual:`BSON document size limit </reference/limits/#mongodb-limit-BSON-Document-Size>`
  of 16 megabytes.

- Pipeline stages have a memory limit of 100 megabytes by default. If required, you can exceed this limit by setting
  the `AllowDiskUse <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.AggregateOptions.AllowDiskUse.html#MongoDB_Driver_AggregateOptions_AllowDiskUse>`__
  property of the ``AggregateOptions`` object that you pass to the ``Aggregate()`` method.

Link to Stages page
Link to Operators page

Build an Aggregation Pipeline
-----------------------------

The following sections describe the different ways to build an aggregation
pipeline by using the {+driver-long+}.

Builders
~~~~~~~~

You can create an aggregation pipeline in the following ways:

-  Create an ``EmptyPipelineDefinition<TDocument>`` object and chain calls to the relevant
   aggregation methods. Then, pass the pipeline object to the ``IMongoCollection<TDocument>.Aggregate()``
   method. as shown in the following example:

- Chain aggregation methods directly from the call to the
  ``IMongoCollection<TDocument>.Aggregate()`` method.

Select the :guilabel:`EmptyPipelineDefinition` 
or :guilabel:`Aggregate` tab to see the corresponding code:

.. tabs::
    
   .. tab:: EmptyPipelineDefinition
      :tabid: empty-pipeline-definition

      .. code-block:: csharp

         // Defines the aggregation pipeline
         var pipeline = new EmptyPipelineDefinition<Movie>()
            .Match(...)
            .Group(...)
            .Merge(...);

         // Executes the aggregation pipeline
         var results = collection.Aggregate(pipeline).ToList();

   .. tab:: Aggregate
      :tabid: aggregate

      .. code-block:: csharp

         // Defines and executes the aggregation pipeline
         var pipeline = collection.Aggregate()
            .Match(...)
            .Group(...)
            .Merge(...);

LINQ
~~~~

You can use LINQ to create an :ref:`aggregation pipeline <aggregation-pipeline-intro>`.
The {+driver-short+} automatically translates each LINQ statement into the corresponding
aggregation pipeline stages. In this section you can learn which
aggregation pipeline stages are supported.

To learn more about the aggregation pipeline stages, see the 
:ref:`aggregation-pipeline-operator-reference` page in the server manual.

In this guide you can learn how to use
`LINQ <https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/?redirectedfrom=MSDN>`__
with the {+driver-long+}. LINQ allows you to construct queries against
strongly typed collections of objects by using language keywords and operators.
The {+driver-short+} automatically translates LINQ queries into
:manual:`aggregation operations </aggregation>`.

.. important:: 

   LINQ3 is the only LINQ provider available in the {+driver-long+}. If you have
   manually configured your project to use LINQ2, it will not compile.

To use LINQ to query your collection, you must first create an
an `IQueryable
<https://learn.microsoft.com/en-us/dotnet/api/system.linq.iqueryable?view=net-7.0>`__
object that links to the collection. To create the object, use the ``AsQueryable()`` method
as follows:

.. code-block:: csharp
   :emphasize-lines: 3

   var restaurantsDatabase = client.GetDatabase("sample_restaurants");
   var restaurantsCollection = restaurantsDatabase.GetCollection<Restaurant>("restaurants");
   var queryableCollection = restaurantsCollection.AsQueryable();

Once you have the queryable object, you can compose a query using 
**method syntax**. Some pipeline stages also support **query comprehension syntax**,
which resembles SQL query syntax.

Select the :guilabel:`Method Syntax` or :guilabel:`Query Syntax` tab to see 
how to compose a query using LINQ:

.. tabs::

   .. tab:: Method Syntax
      :tabid: method-syntax

      .. code-block:: csharp

         var query = queryableCollection
             .Where(r => r.Name == "The Movable Feast")
             .Select(r => new { r.Name, r.Address });

   .. tab:: Query Syntax
      :tabid: query-syntax

      .. code-block:: csharp

         var query = from r in queryableCollection
             where r.Name == "The Movable Feast"
             select new { r.Name, r.Address };

You can print the results of the preceding example as follows: 

.. io-code-block::

   .. input::
      :language: csharp

      foreach (var restaurant in query)
      {
          Console.WriteLine(restaurant.ToJson());
      }

   .. output::
      
      { "name" : "The Movable Feast", "address" : { "building" : "284", "coord" : [-73.982923900000003, 40.6580753], "street" : "Prospect Park West", "zipcode" : "11215" } }

.. tip:: Accessing Query Results

   You can also access the results of your query by using the ``ToList()`` or
   ``ToCursor()`` methods:

   .. code-block:: csharp

      var results = query.ToList();

   .. code-block:: csharp

      var results = query.ToCursor();

View Translated Queries
-----------------------

When you run a LINQ query, the {+driver-short+} automatically translates your
query into an aggregation pipeline written with the {+query-api+}. You can view
the translated query by using the ``ToString()`` method or the
``LoggedStages`` property.

To see the translated query for **non-scalar operations**, use the ``ToString()``
method. Non-scalar operations are operations that return a query object, such
as:

- ``Where``
- ``Select``
- ``SelectMany``
- ``GroupJoin``

The following example calls the ``ToString()`` method on a LINQ query and prints
the translated query:

.. io-code-block::

   .. input::
      :language: csharp

       var queryableCollection = _restaurantsCollection.AsQueryable();
       var query = queryableCollection
            .Where(r => r.Name == "The Movable Feast");

       var queryTranslated = query.ToString();
       Console.WriteLine(queryTranslated);

   .. output::

      sample_restaurants.restaurants.Aggregate([{ "$match" : { "name" : "The Movable Feast" } }])

To get the translated query for **scalar operations** use the ``LoggedStages``
property. Scalar operations are operations that return a scalar result rather than a
query object, such as:

- ``First`` 
- ``Sum``
- ``Count``
- ``Min``
- ``Max``

To get a translated query with the ``LoggedStages`` property, you must save
the translated query directly after it is executed, and before executing any
other queries with the same queryable object.

The following example uses the ``LoggedStages`` property on a LINQ query that
uses a scalar operation, then prints the translated query:

.. io-code-block::

   .. input::
      :language: csharp
      :emphasize-lines: 6


      var queryableCollection = _restaurantsCollection.AsQueryable();
      var query = queryableCollection
          .Where(r => r.Name == "The Movable Feast");

      var result = query.FirstOrDefault(); 
      var queryTranslated = query.LoggedStages;

      Console.WriteLine(queryTranslated.ToJson());

   .. output::

      [{ "$match" : { "name" : "The Movable Feast" } }, { "$limit" : NumberLong(1) }]

.. important::

   ``LoggedStages`` is not thread-safe. Executing a query and accessing the
   associated ``LoggedStages`` property from multiple threads might have
   non-deterministic results.

Additional Information
----------------------

MongoDB Server Manual
~~~~~~~~~~~~~~~~~~~~~

To view a full list of expression operators, see 
:manual:`Aggregation Operators </reference/operator/aggregation/>`.

To learn more about assembling an aggregation pipeline and view examples, see
:manual:`Aggregation Pipeline </core/aggregation-pipeline/>`.

To learn more about creating pipeline stages, see 
:manual:`Aggregation Stages </reference/operator/aggregation-pipeline/>`.

To learn about explaining MongoDB aggregation operations, see
:manual:`Explain Results </reference/explain-results/>` and
:manual:`Query Plans </core/query-plans/>`.

API Documentation
~~~~~~~~~~~~~~~~~

For more information about the aggregation operations discussed in this guide, see the
following API documentation:

- `Aggregate() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.IMongoCollection-1.Aggregate.html>`__
- `AggregateOptions <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.AggregateOptions.html>`__
- `Group() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineStageDefinitionBuilder.Group.html>`__
- `Match() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineStageDefinitionBuilder.Match.html>`__
- `Where() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.Linq.MongoQueryable.Where.html>`__
- `GroupBy() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.Linq.MongoQueryable.GroupBy.html>`__
- `Select() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.Linq.MongoQueryable.Select.html>`__
- `PipelineDefinitionBuilder <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineDefinitionBuilder.html>`__

.. TODO: integrate into existing page

Unsupported Aggregation Stages
------------------------------

The {+driver-long+} implementation of LINQ does not support the following
aggregation stages:

- ``$redact``
- ``$geoNear``
- ``$out``

To learn how to create an aggregation pipeline with the ``$out`` stage by using Builders, see
the :ref:`<csharp-builders-out>` section.





Troubleshooting
---------------

.. include:: /includes/troubleshooting/unsupported-filter-expression.rst