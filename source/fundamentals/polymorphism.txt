.. _csharp-polymorphism:

=================
Polymorphic Types
=================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: reference
 
.. meta::
   :keywords: 

Overview
--------

**Polymorphic** classes are classes that
inherit properties and methods from a parent class. Usually, polymorphic types
can be mapped like any other type. However, there are some good things
to know to make sure documents are mapped to the right class.

This guide explains the following:

- How to deserialize polymorphic types
- The discriminator conventions included with the {+driver-short+}
- How to create custom discriminator conventions

For example, suppose you're working with the following {+language+} classes: 

.. code-block:: csharp
   
   public class Animal 
   {
   }

   public class Cat : Animal 
   {
   }

   public class Dog : Animal 
   {
   }

   public class Lion : Cat 
   {
   }

   public class Tiger : Cat 
   {
   }

Specify Subclasses 
------------------

When deserializing polymorphic classes, the serializer must know about
all subclasses in the inheritance hierarchy before it starts deserialization.

Automatic Class Mapping
~~~~~~~~~~~~~~~~~~~~~~~

If you're relying on the automapper to map your classes, you must inform the
serializer about the subclasses it should create class maps for.

One way to do this is by applying the ``[BsonKnownTypes]`` attribute to each base class,
passing the types of its direct child classes as arguments:

.. code-block:: csharp
   
   [BsonKnownTypes(typeof(Cat), typeof(Dog))]
   public class Animal 
   {
   }

   [BsonKnownTypes(typeof(Lion), typeof(Tiger))]
   public class Cat : Animal 
   {
   }

   public class Dog : Animal 
   {
   }

   public class Lion : Cat 
   {
   }

   public class Tiger : Cat 
   {
   }

You can also do this programmatically by calling the ``BsonClassMap.RegisterClassMap()``
method for every class in the hierarchy, as shown in the following example:

.. code-block:: csharp
   
   BsonClassMap.RegisterClassMap<Animal>();
   BsonClassMap.RegisterClassMap<Cat>();
   BsonClassMap.RegisterClassMap<Dog>();
   BsonClassMap.RegisterClassMap<Lion>();
   BsonClassMap.RegisterClassMap<Tiger>();

Use Discriminators
------------------

In MongoDB, a **discriminator** is a field added to a document to identify the class
to which the document serializes. When a collection contains more than one type from a
single inheritance hierarchy, discriminators ensure that each
document is serialized to the right class.

**Discriminator conventions** define the field name used for the discriminator and the value
that goes there.
The {+driver-short+} stores the discriminator
value in a field named ``_t`` in the BSON document. Generally, ``_t`` is the second
field in the BSON document after ``_id``.
In this section, you can learn about the discriminator conventions included
with the {+driver-short+} and how to create custom discriminator conventions.

ScalarDiscriminatorConvention
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the {+driver-short+} uses the ``ScalarDiscriminatorConvention``. In this
convention, the value of the ``_t`` field is the name of the class from which the
document was serialized.

If you serialized one object of each of the previous types to a single collection, the
{+driver-short+} would apply the ``ScalarDiscriminatorConvention`` and set the value of each
document's ``_t`` field to the class from which the document was serialized. This is
shown in the following example:

.. code-block:: json
   
   { _id: ..., _t: "Animal", ... }
   { _id: ..., _t: "Cat", ... }
   { _id: ..., _t: "Dog", ... }
   { _id: ..., _t: "Lion", ... }
   { _id: ..., _t: "Tiger", ... }

The ``ScalarDiscriminatorConvention`` uses concise discriminator values, but can be
difficult to run a query on. For example, to find all documents of type or subtype ``Cat``,
you would need to list each class you're looking for:

.. code-block:: csharp
   :copyable: true
   
   var query = coll.Aggregate().Match(a => a is Cat || a is Lion || a is Tiger);

HierarchicalDiscriminatorConvention
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To simplify queries against your collection of polymorphic types, you can use the
``HierarchicalDiscriminatorConvention`` instead. In this convention, the value of ``_t``
is an array of discriminator values, one for each level of the class inheritance tree.

To use the ``HierarchicalDiscriminatorConvention``, mark a base class as the root
of a hierarchy. One way to do this is by applying the ``[BsonDiscriminatorAttribute]``
attribute to the root class, passing the ``RootClass`` named parameter:

.. code-block:: csharp
   :emphasize-lines: 1,2 
   
   [BsonDiscriminator(RootClass = true)]
   [BsonKnownTypes(typeof(Cat), typeof(Dog)]
   public class Animal 
   {
   }

You can also do this programmatically by calling the ``SetIsRootClass()`` method when
you register the class map for the root class:

.. code-block:: csharp
   :copyable: true
   :emphasize-lines: 3 
   
   BsonClassMap.RegisterClassMap<Animal>(cm => {
       cm.AutoMap();
       cm.SetIsRootClass(true);
   });
   BsonClassMap.RegisterClassMap<Cat>();
   BsonClassMap.RegisterClassMap<Dog>();
   BsonClassMap.RegisterClassMap<Lion>();
   BsonClassMap.RegisterClassMap<Tiger>();

If you serialized one object of each of the previous types to a single collection, the
{+driver-short+} would apply the ``HierarchicalDiscriminatorConvention`` and the
documents would appear as follows:

{ _id: ..., _t: "Animal", ... }
{ _id: ..., _t: ["Animal", "Cat"], ... }
{ _id: ..., _t: ["Animal", "Dog"], ... }
{ _id: ..., _t: ["Animal", "Cat", "Lion"], ... }
{ _id: ..., _t: ["Animal", "Cat", "Tiger"], ... }

When using the ``HierarchicalDiscriminatorConvention``, you can search for all
documents of type or subtype ``Cat`` by using a single boolean condition, as shown in
the following example:

.. code-block:: csharp
   :copyable: true
   
   var query = coll.Aggregate().Match(a => a is Cat);

Custom Discriminator Conventions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're working with data that doesn't follow the conventions used by the
{+driver-short+}--for example, data inserted into MongoDB by another driver or object
mapper--you might need to use a different value for your discriminator field to
ensure your classes align with those conventions.

You can specify a different value for the discriminator field by applying the
``[BsonDiscriminator]`` attribute to your serialized classes. The following example shows
how to use this attribute to set the value of the discriminator field for the
``Person`` class to "personClass":

.. code-block:: csharp

   [BsonDiscriminator("personClass")]
   public class Person 
   {
       public string Name { get; set; }
       public int Age { get; set; }
       public List<string> Hobbies {get; set;}
   }

You can also set the value of the discriminator field programmatically when you
register a class map, as follows:

.. code-block:: csharp

   BsonClassMap.RegisterClassMap<Person>(classMap => 
   {
       classMap.AutoMap();
       classMap.SetDiscriminator("personClass");
   });

A document mapped to the ``Person`` class with the
"personClass" discriminator appears as follows after serialization: 

.. code-block:: json

   { "_id": "...", "_t": "personClass", "Name": "...", "Age": "...", "Hobbies": [...]}

.. TODO: link to class map page




