.. _csharp-builders:

========================
Operations with Builders
========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn about the helper classes, or **builders**, that
the {+driver-short+} provides to construct various types used in the
driver. The driver includes types related to the
specification of filters, updates, projections, sorts, and index keys,
and you can use builders to aid in the creation of these definitions.
Using the builder classes, you leverage the power of the
{+lang-framework+} compiler and your IDE to find errors during
development and your IDE for discovery and code completion.

When you use builders, the compiler and the IDE catch errors such as
misspelled operators early on. Using builders helps you avoid pushing
errors to runtime instead of compile time.

.. tip:: MDB Analyzer

   The **MongoDB Analyzer** is a tool that helps you analyze your
   builders expressions and understand how your {+lang-framework+} code
   translates into the MongoDB Query API. For more information and
   installation instructions, see the `MongoDB Analyzer reference page <https://www.mongodb.com/docs/mongodb-analyzer/current/>`__.

You should read this guide if you want to learn more about how to
construct definitions and build up syntax using builders.

Sample Class
------------

The code examples in this guide demonstrate how you can use builders to
create types to interact with documents in the sample collection ``plants.flowers``.
Documents in this collection are modeled by the following ``Flower`` class:

.. literalinclude:: /includes/fundamentals/code-examples/builders.cs
   :language: csharp
   :dedent:
   :start-after: start-model
   :end-before: end-model

Each builder class takes a generic type parameter
``TDocument`` which represents the type of document that you are working
with. In this guide, the ``Flower`` class is the document type used in
each builder class example.

Construct a Filter
------------------

The ``FilterDefinitionBuilder`` class provides a type-safe interface for
building up queries. Suppose you want to query your collection for
documents matching the following criteria:

- ``Price`` field value less than 20
- ``Category`` field value is "Perennial"

Use builders to create the filter definition using string-based field names:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Filter;
   var filter = builder.Lt("Price", 20) & builder.Eq("Category", "Perennial");

Alternatively, you can use the typed variant to contruct the filter:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Filter;
   var filter = builder.Lt(flower => flower.Price, 20) & builder.Eq(flower => flower.Category, "Perennial");
   
Using the typed variant form provides compile-time safety. Additionally,
your IDE can provide refactoring support.

Array Operators
~~~~~~~~~~~~~~~

If your document has properties or fields that serialize to arrays,
you can use the methods beginning with ``Any``, such as ``AnyEq()`` or
``AnyLt()`` to compare the entire array against a single item.

Use builders to check which documents in the collection have a
``Season`` array that includes `"winter":

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Filter;
   var filter = builder.AnyEq(flower => flower.Season, "winter");

.. TODO for a complete list of expressions, see the Query page?

Create a Projection
-------------------

The ``ProjectionDefinitionBuilder`` class provides a type-safe interface for
defining a projection. Suppose you want to create a projection on the
``Name`` and ``Price`` fields, but exclude the ``Id`` field.

Use builders to create the projection definition using string-based field names:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Projection;
   var projection = builder.Include("Name").Include("Price").Exclude("Id");

You can also use the typed variant to define the projection:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Projection;
   var projection = builder.Include(flower => flower.Name).Include(flower => flower.Price).Exclude(flower => flower.Id);
   
Finally, you can use the ``Expression()`` method to define the
projection:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Projection;
   var projection = builder.Expression(flower => new { Name = flower.Name, Price = flower.Price });

This definition has a return type of ``ProjectionDefinition<TDocument,
TProjection>`` as opposed to the others which return a
``ProjectionDefinition<TDocument>``.

Lambda Expressions
~~~~~~~~~~~~~~~~~~

The driver supports using expression trees to render projections. A
lambda expression contains all the information necessary to form both
the projection on the server as well as the client-side result and
requires no further information.

When you define a ``Find()`` projection using the ``Expression()``
method to create a lambda expression, the
projection is run client-side. The driver inspects the lambda expression
to determine which fields are referenced and automatically constructs a
server-side projection to return only those fields.

You can use lambda expressions to create new fields by performing
operations on values in your documents. The following example shows how
you can use a lambda expression to project a new ``Profit`` field
using the ``Price`` and ``Stock`` fields:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Projection;
   var projection = builder.Expression(flower => new { Profit = flower.Price * flower.Stock });

The result includes only the ``Profit`` field and automatically excludes
the``Id`` field. This occurs because the driver inspects the expression
tree to discover all the fields that are used and tells the server to
include them. The driver runs the lambda expression client-side. As
such, ``Find()`` projections support virtually the entire breadth of the
{+language+} language.

Define a Sort
-------------

The ``SortDefinitionBuilder`` class provides a type-safe interface for
building up sort syntax. Suppose you want to define a sort with the
following order:

- Ascending on ``Price``
- Descending on ``Category``

Use builders to create the sort definition using string-based field names:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Sort;
   var sort = builder.Ascending("Price").Descending("Category");

Alternatively, you can use the typed variant to define the sort:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Sort;
   var sort = builder.Ascending(flower => flower.Price).Descending(flower => flower.Category);
   
Define an Update
----------------

The ``UpdateDefinitionBuilder`` class provides a type-safe interface for
building up an update specification. Suppose you want to create an
update specification with the following criteria:

- Create a new field ``SunRequirement``
- Multiply the ``Price`` field value by 0.9

Use builders to create the update specification using string-based field names:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Update;
   var update = builder.Set("SunRequirement", "Full sun").Mul("Price", 0.9);

Alternatively, you can use the typed variant to define the update:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.Update;
   var update = builder.Set(flower => flower.SunRequirement, "Full sun").Mul(flower => flower.Price, 0.9);

Define Index Keys
-----------------

The ``IndexKeysDefinitionBuilder`` class provides a type-safe interface for
defining index keys. Suppose you want to select ``Category`` as an
ascending index key.

Use builders to select the index key using string-based field names:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<BsonDocument>.IndexKeys;
   var keys = builder.Ascending("Category");

Alternatively, you can use the typed variant to select the index key:

.. code-block:: csharp
   :copyable: true

   var builder = Builders<Flower>.IndexKeys;
   var keys = builder.Ascending(flower => flower.Category);

The ``IndexKeysDefinitionBuilder`` class also provides methods to build
a wildcard index. You can create a wildcard index using ``All field paths`` or ``A
single field path``, in this case using ``Category``:

.. tabs::

   .. tab:: ``All field paths``
      :tabid: all-wildcard-index

      .. code-block:: csharp
         :copyable: true

         var builder = Builders<Flower>.IndexKeys;
         var keys = builder.Wildcard();

   .. tab:: ``A single field path``
      :tabid: single-wildcard-index

      .. code-block:: csharp
         :copyable: true

         var builder = Builders<Flower>.IndexKeys;

         // Using string-based field names
         var keys = builder.Wildcard("Category");

         // Using a typed variant
         var keys = builder.Wildcard(flower => flower.Category);

API Documentation
-----------------

To learn more about any of the methods or types discussed in this
guide, see the following API Documentation:

- `FilterDefinitionBuilder <{+api-root+}/T_MongoDB_Driver_FilterDefinitionBuilder_1.htm>`__
- `ProjectionDefinitionBuilder <{+api-root+}/T_MongoDB_Driver_ProjectionDefinitionBuilder_1.htm>`__
- `SortDefinitionBuilder <{+api-root+}/T_MongoDB_Driver_SortDefinitionBuilder_1.htm>`__
- `UpdateDefinitionBuilder <{+api-root+}/T_MongoDB_Driver_UpdateDefinitionBuilder_1.htm>`__
- `IndexKeysDefinitionBuilder <{+api-root+}/T_MongoDB_Driver_IndexKeysDefinitionBuilder_1.htm>`__