.. _csharp-poco:

=====
POCOs
=====

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: reference

.. meta::
   :keywords: .NET, object, custom class, attributes, code example

Overview
--------

In this guide, you can learn about how you can use ":wikipedia:`Plain Old CLR/Class
Objects <Plain_old_CLR_object>`", or **POCOs**, with the {+driver-short+} for your operations
and queries. POCOs are simple class objects that do not inherit
features from any framework-specific base classes or interfaces. We recommend
using POCOs in your {+language+} code to adhere to idiomatic driver usage and
achieve the best performance.

You should read this guide if you want to learn more about how to use
POCOs with the {+driver-short+} or if you need to adjust the driver's default
field mapping behavior.

Create a POCO
-------------

You can create a POCO by defining a simple class that does not
implement interfaces or extend classes from a framework. When you
execute an operation such as a read or write using a POCO, the driver
internally *serializes*, or converts, the POCO to BSON.

Select the :guilabel:`POCO` or :guilabel:`BSON` tab to see how the
driver serializes a sample POCO to BSON:

.. tabs::

   .. tab:: POCO
      :tabid: poco-representation

      .. code-block:: csharp
         :copyable: false

         public class Clothing
         {
             public ObjectId Id { get; set; }
             public string Name { get; set; }
             public bool InStock { get; set; }
             public double Price { get; set; }
             public int Upc { get; }
             public List<string> ColorSelection { get; set; }
         }

   .. tab:: BSON
      :tabid: bson-representation

      .. code-block:: json
         :copyable: false

         {
           "_id": ObjectId("..."),
           "Name": "Long Sleeve Shirt",
           "InStock": true,
           "Price": 17.99,
           "ColorSelection": [ "black", "navy", "red" ]
         }

You can define a POCO with any object structure that suits your
needs, including nested objects, arrays, lists, and any data types.

.. _csharp-custom-serialization:

Custom Serialization
--------------------

If the default field mapping behavior does not meet your needs, you can
specify custom behavior using serialization-related attributes. These
attributes change the way that the driver serializes each property of
your POCO. This section describes some of the common
serialization-related attributes.


Serialize Read-Only Properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If a property is read-only, the automapper doesn't include it in the class map for
serialization. To force the automapper to include a property, apply the ``[BsonElement]``
attribute to the property.

The following code example applies the ``[BsonElement]`` attribute to the ``Upc`` property
of the ``Clothing`` class:

.. code-block:: csharp
   :copyable: false
   :emphasize-lines: 7-8

   public class Clothing
   {
       public ObjectId Id { get; set; }
       public string Name { get; set; }
       public bool InStock { get; set; }
       public double Price { get; set; }
       [BsonElement]
       public int Upc { get; }
       public List<string> ColorSelection { get; set; }
   }
         
In the previous example, the {+driver-short+} will serialize the ``Upc`` property to a
field named ``Upc`` in the BSON document.

You can also add a read-only property to the class map manually, as shown in the
following example:

.. code-block:: csharp
   
   BsonClassMap.RegisterClassMap<Clothing>(classMap => 
   {
       classMap.AutoMap();
       classMap.MapProperty(c => c.Upc);
   });

.. note::

   When the {+driver-short+} serializes a read-only property, the property's value is
   stored in the database, but never deserialized again.

Set Field Names
~~~~~~~~~~~~~~~

The driver serializes POCO properties to BSON fields with the same field
name and capitalization. To store a property under a different name, use
the ``[BsonElement()]`` attribute. The following code maps the
``YearBuilt`` property of the ``House`` class to the ``year_built``
field in the serialized BSON document:

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonElement("year_built")]
       public int YearBuilt { get; set; }
   }

Though it is common to use the Pascal case naming convention when
defining {+language+} classes, using the ``[BsonElement()]`` attribute
allows you to select a different or custom naming convention in your
MongoDB collection.

.. tip:: Set Custom Field Name Convention
   
   If you want to serialize every property with a custom field name, you
   can define a ``ConventionPack`` instead of using the
   ``[BsonElement()]`` attribute. For example, if you define your class
   using the Pascal case naming convention, you can use the following
   code to use camel case field names in the serialized document:

   .. code-block:: csharp

      var camelCaseConvention = new ConventionPack { new CamelCaseElementNameConvention() };
      ConventionRegistry.Register("CamelCase", camelCaseConvention, type => true);

Select Type Representation
~~~~~~~~~~~~~~~~~~~~~~~~~~

To serialize a {+language+} property to a specific BSON type, use the
``[BsonRepresentation()]`` attribute. This works only if the
{+language+} primitive type is convertible to the BSON type you specify.
In the following code sample, the ``YearBuilt`` property, defined as a
``char`` in {+language+}, is serialized as a BSON ``Int32`` type:

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonRepresentation(BsonType.Int32)]
       public char YearBuilt { get; set; }
   }

For more information on valid type conversions, see the `{+language+}
Conversions Specification
<https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions>`__.

Set Field Order
~~~~~~~~~~~~~~~

The driver serializes properties to BSON fields in the order they
are specified in the POCO. To store properties in a custom order to
match an existing schema, you can specify the ``Order`` named
parameter in the ``[BsonElement()]`` attribute. In the following code
sample, the driver stores the ``YearBuilt`` property after the
``Style`` property:

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonElement(Order = 2)]
       public int YearBuilt { get; set; }

       [BsonElement(Order = 1)]
       public string Style { get; set; }
   }

If any properties don't have an explicit ``Order``, the driver will
serialize them in the default order after those that do.

Identify ``Id`` Property
~~~~~~~~~~~~~~~~~~~~~~~~

By default, the driver maps any public property named ``Id``, ``id``, or
``_id`` to the BSON ``_id`` field. To explicitly select the
property to map to the ``_id`` field, use the ``[BsonId()]`` attribute.
The following code sample maps the ``Identifier`` property to the
``_id`` field:

.. code-block:: csharp
   :copyable: true

   public class House
   {
       [BsonId]
       public string Identifier { get; set; }
   }

.. warning:: Multiple Id Fields

   If you identify more than one property as the ``_id`` field using the
   ``[BsonId()]`` attribute, the driver throws a
   ``DuplicateBsonMemberMapAttributeException``. If you specify the same 
   database field more than once
   (for example, if your POCO includes properties named ``Id`` and ``_id``), 
   the driver throws a ``BsonSerializationException``.

Specify an ID Generator
~~~~~~~~~~~~~~~~~~~~~~~

When you insert a document into a collection, if the ``Id`` property doesn't have a value,
the driver generates a unique value for it.

Because the ``Id`` property can be of any data type, the driver uses an ``IIdGenerator``
object to check and generate values for the property. For the following
commonly used data types, the driver automatically uses the appropriate ``IIdGenerator``
type:

.. list-table::
   :header-rows: 1
   :stub-columns: 1
   :widths: 10 10

   * - ``Id`` Data Type
     - ``IIdGenerator`` Type
   * - ``Guid``
     - ``GuidGenerator``
   * - ``ObjectId``
     - ``ObjectIdGenerator``
   * - ``string``, represented externally as ``ObjectId``
     - ``StringObjectIdGenerator``

For all other data types, you must use the ``[BsonId(IdGenerator)]`` attribute to specify the
``IIdGenerator`` the driver should use to generate an ID. has the following Id generators built-in:

.. list-table::
   :header-rows: 1
   :stub-columns: 1
   :widths: 10 10

   * - ``Id`` Data Type
     - ``IIdGenerator`` Type
   * - ``Guid`` values generated by the COMB algorithm
     - ``CombGuidGenerator``
   * - Only checks that the ID is not null 
     - ``NullIdChecker``
   * - Only checks that the ID is not all zeroes 
     - ``ZeroIdChecker<T>``
   * - ``BsonObjectId``
     - ``BsonObjectIdGenerator``

The following code example uses the ``[BsonId(IdGenerator)]`` attribute to instruct the driver
to use the COMB algorithm to verify and, if needed, generate a value for the ``Id``
property of the ``House`` class:

.. code-block:: csharp
   :copyable: false
   :emphasize-lines: 3
   
   public class House
   {
       [BsonId(IdGenerator = typeof(CombGuidGenerator))]
       public Guid Id { get; set; }
   }

.. note::
   
   If the previous code example didn't use the ``[BsonId]`` attribute, the driver
   would automatically use the ``GuidGenerator`` type to verify and generate the ID value.

You can also specify an ``IIdGenerator`` type while registering the class map, as shown in
the following example:

.. code-block:: csharp
   :copyable: true

   BsonClassMap.RegisterClassMap<House>(classMap => 
   {
      classMap.AutoMap();
      classMap.MapIdMember(h => h.Id).SetIdGenerator(CombGuidGenerator.Instance);
   });

.. tip:: Specify an ``IIdGenerator`` for Multiple Classes

   You can use the ``RegisterIdGenerator()`` method to specify a single ``IIdGenerator``
   for all ``Id`` properties of a certain data type. The following code example instructs
   the driver to use the ``CombGuidGenerator`` type for all ``Guid`` IDs:

   .. code-block:: csharp
      :copyable: true
   
      BsonSerializer.RegisterIdGenerator(
        typeof(Guid),
        CombGuidGenerator.Instance
      );

Omit Empty Fields
~~~~~~~~~~~~~~~~~

By default, the driver serializes undefined properties to fields with ``null``
values. To ignore undefined properties during serialization, use the ``[BsonIgnore]``
attribute. The following code shows how you can prevent the driver from
serializing the ``YearBuilt`` property if it is undefined:

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonIgnore]
       public int YearBuilt { get; set; }
       public string Style { get; set; }
   }

Customize Default Values
~~~~~~~~~~~~~~~~~~~~~~~~

In {+language+}, until a value is assigned to a class property, the property's value
is the default value that corresponds to its data type.

By default, if a property contains the default value for its data type, the
{+driver-short+} serializes this value to the database.
To ignore a property if it contains the default value, use the ``[BsonIgnoreIfDefault]``
attribute.

The following code example applies the ``[BsonIgnoreIfDefault]`` attribute to the
``YearBuilt`` property. If the value of this property is the default for its data type
(``0``), the driver won't serialize it.

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonIgnoreIfDefault]
       public int YearBuilt { get; set; }
   }

You can also instruct the driver to ignore properties containing default values when
you register the class map, as shown in the following example:

.. code-block:: csharp
   :copyable: true

   BsonClassMap.RegisterClassMap<House>(classMap => 
   {
      classMap.AutoMap();
      classMap.MapMember(h => h.YearBuilt).SetIgnoreIfDefault(true);
   });

Instead of ignoring a property that contains a default value, you can assign a different
default value to it. To use a different default value for a property, use the
``[BsonDefaultValue()]`` attribute and pass the desired default value as an argument.

The following code examples applies the ``[BsonDefaultValue()]`` attribute to the
``YearBuilt`` property. Until this property is given a value, its value will be ``1900``. 

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonDefaultValue(1900)]
       public int YearBuilt { get; set; }
   }

You can also specify a different default value for a property when
you register the class map, as shown in the following example:

.. code-block:: csharp
   :copyable: true

   BsonClassMap.RegisterClassMap<House>(classMap => 
   {
      classMap.AutoMap();
      classMap.MapMember(h => h.YearBuilt).SetDefaultValue(1900);
   });

You can both specify a different default value for a property and instruct the driver to
ignore the property if it contains this default value.
In the following code example, if a value has not been assigned
to the ``YearBuilt`` property, it will have the specified default value ``1900``. Because
``1900`` is the default value for this property, the driver will ignore the property if
it has this value.

.. code-block:: csharp
   :copyable: true

   public class House
   {
       public Guid Id { get; set; }

       [BsonDefaultValue(1900)]
       [BsonIgnoreIfDefault] 
       public int YearBuilt { get; set; }
   }

Customize DateTime Serialization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``[BsonDateTimeOptions()]`` attribute lets you customize serialization of ``DateTime``
properties.

If you specify ``[BsonDateTimeOptions(DateOnly = true)]``, the driver sees that this
property contains only a date and doesn't perform time-zone conversion on the value. In
the following code example, the ``PatientRecord`` class uses a ``DateTime`` for the
``DateOfBirth`` property, and includes the ``[BsonDateTimeOptions(DateOnly = true)]``
property to specify that the property contains only a date:

.. code-block:: csharp
   :copyable: true

   public class PatientRecord
   {
       public Guid Id { get; set; }

       [BsonDateTimeOptions(DateOnly = true)]
       public DateTime DateOfBirth { get; set; }

       [BsonDateTimeOptions(Kind = DateTimeKind.Local)]
       public DateTime AppointmentTime { get; set; }
   }

You can also use the ``[BsonDateTimeOptions()]`` attribute to specify the ``DateTimeKind``
of the ``DateTime``. The possible values for the ``DateTimeKind`` are defined in the
``DateTimeKind`` enum.

In the following code example, the ``PatientRecord`` class uses a ``DateTime`` for the
``AppointmentTime`` property, and includes the ``[BsonDateTimeOptions(Kind = DateTimeKind.Local)]``
property to specify that the time component of the property's value is in local time. The
driver will convert the value to UTC when it serializes it to MongoDB, where values are
always stored in UTC. 

.. code-block:: csharp
   :copyable: true

   public class PatientRecord
   {
       public Guid Id { get; set; }

       [BsonDateTimeOptions(DateOnly = true)]
       public DateTime DateOfBirth { get; set; }

       [BsonDateTimeOptions(Kind = DateTimeKind.Local)]
       public DateTime AppointmentTime { get; set; }
   }

You can also specify the one or both of the previous ``DateTime`` options when
registering the class map:

.. code-block:: csharp
   :copyable: true

   BsonClassMap.RegisterClassMap<House>(classMap => 
   {
      classMap.AutoMap();
      classMap.MapMember(p => p.DateOfBirth).SetSerializer(new DateTimeSerializer(dateOnly: true));
      classMap.MapMember(p => p.AppointmentTime).SetSerializer(new DateTimeSerializer(DateTimeKind.Local));
   });

Customize Dictionary Serialization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``DictionaryRepresentation`` enum defines the following ways in which you can store a
``Dictionary`` in MongoDB:

- **Document**: The driver serializes the ``Dictionary`` to a ``BsonDocument``. each
  entry in the dictionary is represented by a ``BsonElement``, with the name equal to
  the key of the dictionary entry and the value equal to the value. You can
  use this representation only when all the keys in the dictionary are strings that
  are valid element names.
- **ArrayOfArrays**: The driver serializes the dictionary to a ``BsonArray`` of key/value
  pairs, where each key/value pair is stored as a nested two-element ``BsonArray`` where
  the two elements are the key and the value of the dictionary entry. You can use this
  representation even when the keys of the dictionary are not strings. This
  representation is very general and compact, and is the default representation when
  Document does not apply. One problem with this representation is that it is difficult
  to write queries against it, which motivated the introduction in the 1.2 version of the
  driver of the ArrayOfDocuments representation.
- **ArrayOfDocuments**: The driver serializes the dictionary as a ``BsonArray`` of
  key/value pairs, where each key/value pair is stored as a nested two-element
  ``BsonDocument`` of the form { k : key, v : value }. This representation is just
  as general as the ArrayOfArrays representation, but because the keys and values are
  tagged with element names it is much easier to write queries against it.

Example
-------

The following example shows how to insert a ``Clothing`` document with custom field
mapping specifications into MongoDB.

The following code defines the ``Clothing`` class with these
serialization-related attributes:

- ``[BsonElement()]``, which specifies custom field names in the camel case naming convention
- ``[BsonRepresentation()]``, which specifies serialization of the ``Price`` field as a BSON ``Double`` type

.. literalinclude:: ../../includes/fundamentals/code-examples/Clothing.cs
   :start-after: start-model
   :end-before: end-model
   :language:  csharp
   :copyable:
   :dedent:

The following code instantiates a ``Clothing`` object and inserts the document into a collection:

.. code-block:: csharp

   var doc = new Clothing
   {
       Name = "Denim Jacket",
       InStock = false,
       Price = 32.99m,
       ColorSelection = new List<string> { "dark wash", "light wash" }
   };

   _myColl.InsertOne(doc);

The BSON representation of the inserted document looks like this:

.. code-block:: json
   :copyable: false

   {
     "_id": ObjectId("..."),
     "name": "Denim Jacket",
     "inStock": false,
     "price": 32.99,
     "colorSelection": [ "dark wash", "light wash" ]
   }

Additional Information
----------------------

For a full list of serialization-related attributes, see the
`Serialization.Attributes API documentation <{+new-api-root+}/MongoDB.Bson/MongoDB.Bson.Serialization.Attributes.html>`__.

For additional read and write operation examples using POCOs, see the :ref:`Usage Examples
<csharp-usage-examples>` or the :ref:`CRUD Fundamentals Pages <csharp-crud>`.

To learn more about how the driver maps BSON documents to POCOs, see
:ref:`csharp-class-mapping`.

API Documentation
~~~~~~~~~~~~~~~~~

To learn more about any of the methods or types discussed in this
guide, see the following API documentation:

- `[BsonElement()] <{+new-api-root+}/MongoDB.Bson/MongoDB.Bson.Serialization.Attributes.BsonElementAttribute.html>`__
- `[BsonRepresentation()] <{+new-api-root+}/MongoDB.Bson/MongoDB.Bson.Serialization.Attributes.BsonRepresentationAttribute.html>`__
- `[BsonId()] <{+new-api-root+}/MongoDB.Bson/MongoDB.Bson.Serialization.Attributes.BsonIdAttribute.html>`__
- `[BsonIgnore()] <{+new-api-root+}/MongoDB.Bson/MongoDB.Bson.Serialization.Attributes.BsonIgnoreAttribute.html>`__
- `ConventionPack <{+new-api-root+}/MongoDB.Bson/MongoDB.Bson.Serialization.Conventions.ConventionPack.html>`__
- `InsertOne() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.IMongoCollection-1.InsertMany.html>`__