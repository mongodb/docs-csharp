.. _csharp-aggregation:

===========
Aggregation
===========

.. facet::
   :name: genre
   :values: reference
 
.. meta::
   :keywords: code example, transform, pipeline

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn how to use the {+driver-long+} to perform
**aggregation operations**.

Aggregation operations process data in your MongoDB collections and
return computed results. The MongoDB Aggregation framework is modeled on the 
concept of data processing pipelines. Documents enter a pipeline comprised of one or
more stages, and this pipeline transforms the documents into an aggregated result.

Analogy
~~~~~~~

Aggregation operations function similarly to car factories with assembly
lines. The assembly lines have stations with specialized tools to
perform specific tasks. For example, when building a car, the assembly
line begins with the frame. Then, as the car frame moves through the
assembly line, each station assembles a separate part. The result is a
transformed final product, the finished car.

The assembly line represents the *aggregation pipeline*, the individual
stations represent the *aggregation stages*, the specialized tools
represent the *expression operators*, and the finished product
represents the *aggregated result*.

Compare Aggregation and Find Operations
---------------------------------------

The following table lists the different tasks you can perform with find
operations, compared to what you can achieve with aggregation
operations. The aggregation framework provides expanded functionality
that allows you to transform and manipulate your data.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Find Operations
     - Aggregation Operations

   * - | Select *certain* documents to return
       | Select *which* fields to return
       | Sort the results
       | Limit the results
       | Count the results
     - | Select *certain* documents to return
       | Select *which* fields to return
       | Sort the results
       | Limit the results
       | Count the results
       | Group the results
       | Rename fields
       | Compute new fields
       | Summarize data
       | Connect and merge data sets

Server Limitations
------------------

Consider the following :manual:`limitations </core/aggregation-pipeline-limits/>` when 
performing aggregation operations:

- Returned documents must not violate the :manual:`BSON document size limit </reference/limits/#mongodb-limit-BSON-Document-Size>`
  of 16 megabytes.

- Pipeline stages have a memory limit of 100 megabytes by default. If required, you can exceed this limit by setting
  the `AllowDiskUse <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.AggregateOptions.AllowDiskUse.html#MongoDB_Driver_AggregateOptions_AllowDiskUse>`__
  property of the ``AggregateOptions`` object that you pass to the ``Aggregate()`` method.

- The :manual:`$graphLookup </reference/operator/aggregation/graphLookup/>` stage has
  a strict memory limit of 100 megabytes and ignores the ``AllowDiskUse`` property.

Aggregation Example
-------------------

To perform an aggregation, pass a list of aggregation stages to the
``IMongoCollection<TDocument>.Aggregate()`` method.

.. note::
  
  This example uses the ``sample_restaurants.restaurants`` collection
  from the :atlas:`Atlas sample datasets </sample-data>`. To learn how to create a
  free MongoDB Atlas cluster and load the sample datasets, see :ref:`csharp-get-started`.

The following code example produces a count of the number of bakeries in each borough
of New York City. To do so, it uses an aggregation pipeline that contains the following stages:

- A :manual:`$match </reference/operator/aggregation/match/>` stage to filter for documents whose
  ``cuisine`` field contains the value ``"Bakery"``.

- A :manual:`$group </reference/operator/aggregation/group/>` stage to group the matching
  documents by the ``borough`` field, accumulating a count of documents for each distinct value
  of that field.

The following sections implement this example by using LINQ, Builders, and BsonDocument
approaches to create and combine the aggregation stages used in the example pipeline.

LINQ Approach
~~~~~~~~~~~~~

.. io-code-block::

   .. input:: /includes/fundamentals/code-examples/LinqAggregation.cs
      :language: csharp
      :dedent:
      :start-after: begin-aggregation
      :end-before: end-aggregation
   
   .. output::
      :language: console
      :visible: false

      { _id = Bronx, Count = 71 }
      { _id = Brooklyn, Count = 173 }
      { _id = Staten Island, Count = 20 }
      { _id = Missing, Count = 2 }
      { _id = Manhattan, Count = 221 }
      { _id = Queens, Count = 204 }

To learn more about using LINQ to construct aggregation pipelines, see the
:ref:`csharp-linq` guide.      

Builders Approach
~~~~~~~~~~~~~~~~~

.. io-code-block::

   .. input:: /includes/fundamentals/code-examples/BuilderAggregation.cs
      :language: csharp
      :dedent:
      :start-after: begin-aggregation
      :end-before: end-aggregation
   
   .. output::
      :language: console
      :visible: false

      { _id = Bronx, Count = 71 }
      { _id = Brooklyn, Count = 173 }
      { _id = Staten Island, Count = 20 }
      { _id = Missing, Count = 2 }
      { _id = Manhattan, Count = 221 }
      { _id = Queens, Count = 204 }

To learn more about using builders to construct aggregation pipelines,
see the :ref:`csharp-builders-aggregation` section of the Operations with Builders guide.       

BsonDocument Approach
~~~~~~~~~~~~~~~~~~~~~

.. io-code-block::

   .. input:: /includes/fundamentals/code-examples/Aggregation.cs
      :language: csharp
      :dedent:
      :start-after: begin-aggregation
      :end-before: end-aggregation

   .. output::
      :language: console
      :visible: false

      { "_id" : "Brooklyn", "count" : 173 }
      { "_id" : "Manhattan", "count" : 221 }
      { "_id" : "Bronx", "count" : 71 }
      { "_id" : "Missing", "count" : 2 }
      { "_id" : "Staten Island", "count" : 20 }
      { "_id" : "Queens", "count" : 204 }

Additional Information
----------------------

MongoDB Server Manual
~~~~~~~~~~~~~~~~~~~~~

To view a full list of expression operators, see 
:manual:`Aggregation Operators </reference/operator/aggregation/>`.

To learn more about assembling an aggregation pipeline and view examples, see
:manual:`Aggregation Pipeline </core/aggregation-pipeline/>`.

To learn more about creating pipeline stages, see 
:manual:`Aggregation Stages </reference/operator/aggregation-pipeline/>`.

To learn about explaining MongoDB aggregation operations, see
:manual:`Explain Results </reference/explain-results/>` and
:manual:`Query Plans </core/query-plans/>`.

API Documentation
~~~~~~~~~~~~~~~~~

For more information about the aggregation operations discussed in this guide, see the
following API documentation:

- `Aggregate() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.IMongoCollection-1.Aggregate.html>`__
- `AggregateOptions <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.AggregateOptions.html>`__
- `Group() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineStageDefinitionBuilder.Group.html>`__
- `Match() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineStageDefinitionBuilder.Match.html>`__
- `Where() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.Linq.MongoQueryable.Where.html>`__
- `GroupBy() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.Linq.MongoQueryable.GroupBy.html>`__
- `Select() <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.Linq.MongoQueryable.Select.html>`__

.. TODO: integrate into existing page

Sample Class
------------

The code examples in this guide demonstrate how you can use builders to
create types to interact with documents in the sample collection ``plants.flowers``.
Documents in this collection are modeled by the following ``Flower`` class:

.. literalinclude:: /includes/fundamentals/code-examples/builders.cs
   :language: csharp
   :dedent:
   :start-after: start-model
   :end-before: end-model

Each builder class takes a generic type parameter
``TDocument`` which represents the type of document that you are working
with. In this guide, the ``Flower`` class is the document type used in
each builder class example.

.. _csharp-builders-aggregation:

Build an Aggregation Pipeline
-----------------------------

The ``PipelineDefinitionBuilder`` class provides a type-safe interface for
defining an **aggregation pipeline**. An aggregation pipeline is a series of
stages that are used to transform a document. Suppose you want to create a
pipeline that performs the following operations:

- Matches all documents with "spring" in the ``Season`` field
- Sorts the results by the ``Category`` field
- Groups the documents by category and shows the average price and total
  available for all documents in that category

Use ``PipelineDefinitionBuilder`` classes to build the pipeline:

.. code-block:: csharp

   var sortBuilder = Builders<Flower>.Sort.Ascending(f => f.Category);
   var matchFilter = Builders<Flower>.Filter.AnyEq(f => f.Season, "spring");

   var pipeline = new EmptyPipelineDefinition<Flower>()
       .Match(matchFilter)
       .Sort(sortBuilder)
       .Group(f => f.Category,
              g => new
                 {
                    name = g.Key, 
                    avgPrice = g.Average(f => f.Price), 
                    totalAvailable = g.Sum(f => f.Stock)
                  }
             );   

The preceding example creates the following pipeline:

.. code-block:: json
   
   [{ "$match" : { "season" : "spring" } }, { "$sort" : { "category" : 1 } }, { "$group" : { "_id" : "$category", "avgPrice" : { "$avg" : "$price" }, "totalAvailable" : { "$sum" : "$stock" } } }]

You can add stages to your pipeline that don't have corresponding type-safe
methods in the ``PipelineDefinitionBuilder`` interface by providing your query
as a ``BsonDocument`` to the `AppendStage() method
<{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineDefinitionBuilder.AppendStage.html>`__.

.. code-block:: csharp

   var pipeline = new EmptyPipelineDefinition<BsonDocument>().AppendStage<BsonDocument, BsonDocument, BsonDocument>("{ $set: { field1: '$field2' } }");

.. note:: 

   When using a ``BsonDocument`` to define your pipeline stage, the driver does
   not take into account any ``BsonClassMap``, serialization attributes or
   serialization conventions. The field names used in the ``BsonDocument`` must
   match those stored on the server.

   For more information on providing a query as a ``BsonDocument``, see our
   :ref:`FAQ page <csharp-faq-unsupported-expressions>`.

To learn more about the Aggregation Pipeline, see the
:manual:`Aggregation Pipeline </core/aggregation-pipeline/>` server manual page.

.. _csharp-builders-out:

Write Pipeline Results to a Collection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can write the documents returned from an aggregation pipeline to a
collection by creating an ``$out`` stage at the end of your aggregation
pipeline. To create an ``$out`` stage, call the ``Out()`` method on a
``PipelineStageDefinitionBuilder``. The ``Out()`` method requires the name of
the collection you want to write the documents to.

The following example builds an aggregation pipeline that matches all documents
with a ``season`` field value of ``"Spring"`` and outputs them to
a ``springFlowers`` collection:

.. code-block:: csharp

   var outputCollection = database.GetCollection("springFlowers");
   var matchFilter = Builders<Flower>.Filter.AnyEq(f => f.Season, "spring");

   // Creates an aggregation pipeline and outputs resulting documents to a new collection.
   var pipeline = new EmptyPipelineDefinition<Flower>()
       .Match(matchFilter)
       .Out(outputCollection);

You can write the results of an aggregation pipeline to a time series collection
by specifying a ``TimeSeriesOption`` object and passing it as the second
parameter to the ``Out()`` method.

Imagine that the documents in the ``plants.flowers`` collection contain a ``datePlanted`` field that
holds BSON date values. You can store the documents in this collection in a time
series collection by using the ``datePlanted`` field as the time field.

The following example creates a ``TimeSeriesOptions`` object and specifies
``datePlanted`` as the ``timeField``. It then builds an aggregation pipeline that matches all documents
with a ``season`` field value of ``"Spring"`` and outputs them to a
time series collection called ``springFlowerTimes``.

.. code-block:: csharp

   var timeSeriesOptions = new TimeSeriesOptions("datePlanted");
   var collectionName = "springFlowerTimes"
   var matchFilter = Builders<Flower>.Filter.AnyEq(f => f.Season, "spring");

   // Creates an aggregation pipeline and outputs resulting documents to a time series collection.
   var pipeline = new EmptyPipelineDefinition<Flower>()
       .Match(matchFilter)
       .Out(collectionName, timeSeriesOptions);

To learn more about time series collections, see :ref:`csharp-time-series`.


- `PipelineDefinitionBuilder <{+new-api-root+}/MongoDB.Driver/MongoDB.Driver.PipelineDefinitionBuilder.html>`__