.. _csharp-faq:

===
FAQ
===

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

This page contains frequently asked questions and their corresponding answers.

.. tip::

   If you can't find an answer to your problem on this page,
   see the :ref:`csharp-issues-help` page for next steps and more
   resources.

.. _csharp-faq-connection-pool:

How Does Connection Pooling Work in the {+driver-short+}?
---------------------------------------------------------

Every ``MongoClient`` instance has a built-in connection pool for each server
in your MongoDB topology. Connection pools open sockets on demand to
support concurrent MongoDB operations in your multi-threaded application.

The maximum size of each connection pool is set by the ``MaxConnectionPoolSize`` option, which
defaults to ``100``. If the number of in-use connections to a server reaches
the value of ``MaxConnectionPoolSize``, the next request to that server will wait
until a connection becomes available. 

The driver has a wait queue that limits the number of threads that can
wait for a connection. The size of the wait queue is determined by the
``WaitQueueMultiple`` option, which defaults to ``5``. The wait queue
size is ``WaitQueueMultiple`` x ``MaxConnectionPoolSize``, which is ``500`` by
default. You can also set the wait queue size by specifying the
``WaitQueueSize`` option, which overrides the other settings. However,
we do not recommend changing the wait queue size from the default.

Each ``MongoClient`` instance opens two additional sockets per server in
your MongoDB topology for monitoring the server's state.

For example, a client connected to a 3-node replica set opens 6
monitoring sockets. It also opens as many sockets as needed to support
an application's threads on each server, up to
the value of ``MaxConnectionPoolSize``. If ``MaxConnectionPoolSize`` is ``100`` and the
application only uses the primary (the default), then only the primary
connection pool grows and there can be at most ``106`` total connections. If the
application uses a :ref:`read preference <read-preference>` to query the
secondary nodes, their pools also grow and there can be ``306`` total connections.

Additionally, connection pools are rate-limited such that each connection pool
can only create, at maximum, the value of ``MaxConnecting`` connections
in parallel at any time. Any additional connection stops waiting in the
following cases:

- One of the existing threads finishes creating a connection, or
  an existing connection is checked back into the pool.
- The driver's ability to reuse existing connections improves due to
  rate-limits on connection creation.

You can set the minimum number of concurrent connections to
each server with the ``MinConnectionPoolSize`` option, which defaults to ``0``.
The connection pool will be initialized with this number of sockets. If
sockets are closed due to any network errors, causing the total number
of sockets (both in use and idle) to drop below the minimum, more
sockets are opened until the minimum is reached.

You can set the maximum number of milliseconds that a connection can
remain idle in the pool before being removed and replaced with
the ``MaxConnectionIdleTime`` option, which defaults to 10 minutes.
``MongoClient`` also has the ``MaxConnectionLifeTime`` option, which
specifies the length of time, 30 minutes by default, that a connection
can be pooled before expiring.

The following default configuration for a ``MongoClient`` works for most
applications:

.. code-block:: csharp
   
   var client = new MongoClient("<connection string>");

Create a client once for each process, and reuse it for all
operations. It is a common mistake to create a new client for each
request, which is very inefficient.

To support high numbers of concurrent MongoDB threads
within one process, you can increase ``MaxConnectionPoolSize``.

A thread that waits more than the length of time defined by
``MaxConnectionIdleTime`` for a socket raises a connection error. Use this
option if it is more important to bound the duration of operations
during a load spike than it is to complete every operation.

There is no supported way to terminate a ``MongoClient`` in the driver.

Why Does the Driver Throw a Timeout During Server Selection?
------------------------------------------------------------

Each driver operation requires that you choose a healthy server
satisfying the :manual:`server selection criteria
</core/read-preference-mechanics>`. If you do not select an appropriate
server within the `server selection timeout <{+api-root+}/P_MongoDB_Driver_MongoServerSettings_ServerSelectionTimeout.htm>`__, the driver throws a
server selection timeout exception. The exception looks similar to the
following:

.. code-block:: none

   A timeout occurred after 30000ms selecting a server using CompositeServerSelector{ Selectors = MongoDB.Driver.MongoClient+AreSessionsSupportedServerSelector, LatencyLimitingServerSelector{ AllowedLatencyRange = 00:00:00.0150000 }, OperationsCountServerSelector }.
   Client view of cluster state is 
   { 
       ClusterId : "1", 
       Type : "Unknown", 
       State : "Disconnected", 
       Servers : 
       [{
           ServerId: "{ ClusterId : 1, EndPoint : "Unspecified/localhost:27017" }",
           EndPoint: "Unspecified/localhost:27017",
           ReasonChanged: "Heartbeat",
           State: "Disconnected",
           ServerVersion: ,
           TopologyVersion: ,
           Type: "Unknown",
           HeartbeatException: "<exception details>"
       }] 
   }.

The error message consists of multiple parts:

1. The server selection timeout (30000 ms).
#. The server selectors considered (``CompositeServerSelector``
   containing ``AreSessionsSupportedServerSelector``,
   ``LatencyLimitingServerSelector``, and
   ``OperationsCountServerSelector``).
#. The driver’s current view of the cluster topology. The list of
   servers that the driver is aware of is a key part of this view. Each
   server description contains an exhaustive description of its current
   state including information about an endpoint, a server version, a
   server type, and its current health state. If the server is not
   heathy, ``HeartbeatException`` contains the exception from the
   last failed heartbeat. Analyzing the ``HeartbeatException`` on each
   cluster node can assist in diagnosing most server selection issues.
   The following heartbeat exceptions are common:
   
   * ``No connection could be made because the target machine actively
     refused it``: The driver cannot see this cluster node. This can be
     because the cluster node has crashed, a firewall is preventing
     network traffic from reaching the cluster node or port, or some other
     network error is preventing traffic from being successfully routed to
     the cluster node.
   * ``Attempted to read past the end of the stream``: This error
     happens when the driver cannot connect to the cluster nodes due to a
     network error, misconfigured firewall, or other network issue. To
     address this exception, ensure that all cluster nodes are reachable.
     This error commonly occurs when the client machine’s IP address is
     not configured in the Atlas IPs Access List, which can be found under
     the :guilabel:`Network Access` tab for your Atlas Project.
   * ``The remote certificate is invalid according to the validation
     procedure``: This error typically indicates a TLS/SSL-related problem
     such as an expired/invalid certificate or an untrusted root CA. You
     can use tools like ``openssl s_client`` to debug TLS/SSL-related
     certificate problems.

Why is the Wait Queue for Acquiring a Connection to the Server Full?
--------------------------------------------------------------------

This exception usually indicates a threading or concurrency problem in
your application. The driver checks out a connection from the selected
server’s connection pool for every read or write operation. If
the connection pool is already at ``maxPoolSize`` - 100 by default - then the
requesting thread blocks in a wait queue. The wait queue's default size
is 5 times ``maxPoolSize``, or 500. If the wait queue is also full, the driver
throws a ``MongoWaitQueueFullException``. The exception looks
similar to the following:

.. code-block:: none
   
   MongoDB.Driver.MongoWaitQueueFullException: The wait queue for
   acquiring a connection to server myServer is full.

To resolve this issue, try the following steps:

1. Tune your indexes. By improving the performance of your queries,
   you can reduce the time that operations take and reduce the number of
   concurrent connections needed for your workload.
#. If you have long-running analytical queries, you may wish to isolate
   them to dedicated analytics nodes using :manual:`read preference tags
   </core/read-preference/>` or a hidden secondary.
#. Increase ``maxPoolSize`` to allow more simultaneous operations to a
   given cluster node. If your MongoDB cluster does not have sufficient
   resources to handle the additional connections and simultaneous
   workload, performance can decrease due to resource contention
   on the cluster nodes. Adjust this setting only with careful
   consideration and testing.
#. Increase ``waitQueueMultiple`` to allow more threads/tasks to block
   waiting for a connection. This is rarely the appropriate solution and
   can severely affect your application performance. Before
   considering changes to this setting, address the concurrency problems
   in your application.

.. _csharp-faq-unsupported-expressions:

Why are Certain LINQ or Builder Expressions Unsupported?
--------------------------------------------------------

Each LINQ or Builder expression must be available in the Query API. This is not
always possible for the following reasons:

1. You are attempting to use a {+lang-framework+} feature that does not have an
   equivalent MongoDB representation. For example, {+lang-framework+} and MongoDB have
   different semantics around collations.
#. The driver does not support a particular transformation from LINQ or
   Builder expression into MQL (MongoDB Query Language). This may happen because the
   provided query has no MQL translation or because a feature has not been
   implemented yet in the driver.

If you receive an ``Unsupported filter ...`` or ``Expression not
supported ...`` exception message, try the following
steps:

1. Try configuring the new `LINQ3
   <https://mongodb.github.io/mongo-csharp-driver/2.17/reference/driver/crud/linq3/>`__
   provider. The LINQ3 provider contains many fixes and new features
   over the LINQ2 provider.
#. Use the `MongoDB Analyzer
   <https://www.mongodb.com/docs/mongodb-analyzer/current/>`__ to analyze your
   expressions.
#. Try to simplify your query where possible.
#. Provide a query as a ``BsonDocument`` or JSON string. All driver
   definition classes such as ``FilterDefinition``,
   ``ProjectionDefinition``, and ``PipelineDefinition`` support implicit
   conversion from ``BsonDocument`` or JSON string. For example, the
   following filters are equivalent when used in a query or
   aggregation:

.. code-block:: csharp

   FilterDefinition<Entity> typedFilter = Builders<Entity>.Filter.Eq(e => e.A, 1);
   FilterDefinition<Entity> bsonFilter = new BsonDocument {{ "a", 1 }};
   FilterDefinition<Entity> jsonFilter = "{ a : 1 }";

.. note::

   If you use ``BsonDocument`` or JSON string, then `BsonClassMap
   <https://mongodb.github.io/mongo-csharp-driver/2.17/reference/bson/mapping/>`__,
   BSON serialization attributes, and serialization conventions are not
   taken into account in the Query API. Field names must match the
   names and casing as stored by the server. For example, when referencing
   the ``_id`` field, you must refer to it using ``_id`` in
   ``BsonDocument`` or JSON string definitions. Similarly, if a document
   has a field ``FirstName`` annotated with ``[BsonElement("first_name")]``, you
   must refer to it as ``first_name`` in ``BsonDocument`` or JSON string
   definitions.
   
You can combine the raw and typed forms in the same query, as the
following code demonstrates:

.. code-block:: csharp

   FilterDefinition<Entity> filter = Builders<Entity>.Filter
       .And(Builders<Entity>.Filter
           .Eq(e => e.A, 1), BsonDocument
           .Parse("{ b : 2 }"));