.. _csharp-polymorphism:

=================
Polymorphic Types
=================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: reference
 
.. meta::
   :keywords: 

Overview
--------

**Polymorphic** classes are classes that
inherit properties and methods from a parent class. Usually, polymorphic types
can be mapped like any other type. However, there are some good things
to know to make sure documents are mapped to the right class.

This guide explains the following:

- The default discriminator conventions included with the {+driver-short+}
- How to create custom discriminator conventions
- How to avoid errors when deserializing polymorphic types

Use Discriminators
------------------

In MongoDB, a **discriminator** is a field added to a document to identify the class
the document was serialized from. This is useful when more than one class from an
inheritance hierarchy is serialized to a single collection by ensuring that each
document is correctly deserialized to the right object type.

In this section, you can learn about the default discriminator conventions included
with the {+driver-short+} and how to create custom discriminator conventions.

Default Discriminator Conventions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The default discriminator conventions both use an element named ``_t`` to store the
discriminator value in the BSON document. This element is usually the second
element in the BSON document after ``_id``.

The default serializer in the {+driver-short+} includes the following
discriminator conventions:

.. list-table::
   :header-rows: 1
   :stub-columns: 1
   :widths: 10 20

   * - Discriminator Convention
     - Description

   * - ``HierarchicalDiscriminatorConvention``
     - **Default.** Behaves like the ``ScalarDiscriminatorConvention``
       unless you set options to trigger hierarchical behavior. //TODO
       the value of _t will be
       an array of discriminator values, one for each level of the class inheritance tree.

   * - ``ScalarDiscriminatorConvention``
     - The value of the ``_t`` field is the name of the class from which the document
       was serialized.

Custom Discriminator Conventions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're working with data that doesn't follow the conventions used by the
{+driver-short+}--for example, data inserted into MongoDB by another driver or object
mapper--you might need to use a different value for your discriminator field to
ensure your classes align with those conventions.

You can specify a different value for the discriminator field by applying the
``[BsonDiscriminator]`` attribute to your serialized classes. The following example shows
how to use this attribute to set the value of the discriminator field for the
``Person`` class to "personClass":

.. code-block:: csharp

   [BsonDiscriminator("personClass")]
   public class Person 
   {
       public string Name { get; set; }
       public int Age { get; set; }
       public List<string> Hobbies {get; set;}
   }

You can also set the value of the discriminator field programmatically when you
register a class map, as follows:

.. code-block:: csharp

   BsonClassMap.RegisterClassMap<Person>(classMap => 
   {
       classMap.AutoMap();
       classMap.SetDiscriminator("personClass");
   });

A document mapped to the ``Person`` class with the
"personClass" discriminator appears as follows after serialization: 

.. code-block:: json

   { "_id": "...", "_t": "personClass", "Name": "...", "Age": "...", "Hobbies": [...]}

.. TODO: link to class map page

Specify Subclasses 
------------------

When deserializing polymorphic classes, the serializer must know about
all subclasses in the inheritance hierarchy before it starts deserialization.

Automatic Class Mapping
~~~~~~~~~~~~~~~~~~~~~~~

If you're relying on the automapper to map your classes, you must inform the
serializer about the subclasses it should create class maps for. Here is
an example of how to do this:.
Mark each class with an attribute declaring the classes that directly inherit from it.

[BsonKnownTypes(typeof(Cat), typeof(Dog))]
public class Animal 
{
}

[BsonKnownTypes(typeof(Lion), typeof(Tiger))]
public class Cat : Animal 
{
}

public class Dog : Animal 
{
}

public class Lion : Cat 
{
}

public class Tiger : Cat 
{
}

The BsonKnownTypesAttribute attribute lets the serializer know what subclasses it
might encounter during deserialization, so when Animal is automapped, the serializer
will also automap Cat and Dog, and recursively, Lion and Tiger as well.

Manual Class Mapping
~~~~~~~~~~~~~~~~~~~~

If you're mapping your classes programmatically,
call the ``BsonClassMap.RegisterClassMap()`` method for each class in the hierarchy.

Or via code:

BsonClassMap.RegisterClassMap<Animal>();
BsonClassMap.RegisterClassMap<Cat>();
BsonClassMap.RegisterClassMap<Dog>();
BsonClassMap.RegisterClassMap<Lion>();
BsonClassMap.RegisterClassMap<Tiger>();


Scalar and Hierarchical Discriminators


Normally a discriminator is simply the name of the class (although it could be different
if you are using a custom discriminator convention or have explicitly specified a
discriminator for a class). So a collection containing a mix of different type of Animal
documents might look like:

{ _id: ..., _t: "Animal", ... }
{ _id: ..., _t: "Cat", ... }
{ _id: ..., _t: "Dog", ... }
{ _id: ..., _t: "Lion", ... }
{ _id: ..., _t: "Tiger", ... }

Sometimes it can be helpful to record a hierarchy of discriminator values, one for each
 level of the hierarchy. To do this, you must first mark a base class as being the root
  of a hierarchy, and then the default HierarchicalDiscriminatorConvention will
   automatically record discriminators as array values instead.

To identify Animal as the root of a hierarchy use the BsonDiscriminatorAttribute
attribute with the RootClass named parameter:

[BsonDiscriminator(RootClass = true)]
[BsonKnownTypes(typeof(Cat), typeof(Dog)]
public class Animal 
{
}

// the rest of the hierarchy as before
Or via code:

BsonClassMap.RegisterClassMap<Animal>(cm => {
    cm.AutoMap();
    cm.SetIsRootClass(true);
});
BsonClassMap.RegisterClassMap<Cat>();
BsonClassMap.RegisterClassMap<Dog>();
BsonClassMap.RegisterClassMap<Lion>();
BsonClassMap.RegisterClassMap<Tiger>();

Now that you have identified Animal as a root class, the discriminator values will look 
a little bit different:

{ _id: ..., _t: "Animal", ... }
{ _id: ..., _t: ["Animal", "Cat"], ... }
{ _id: ..., _t: ["Animal", "Dog"], ... }
{ _id: ..., _t: ["Animal", "Cat", "Lion"], ... }
{ _id: ..., _t: ["Animal", "Cat", "Tiger"], ... }
The main reason you might choose to use hierarchical discriminators is because it makes it possibly to query for all instances of any class in the hierarchy. For example, to read all the Cat documents we can use the following filter.

var filter = new BsonDocument("_t", "Cat");